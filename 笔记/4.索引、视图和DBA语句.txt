[TOC]

# 其他

## 1、索引

### 1.1、什么是索引

索引是在数据库表的字段上添加的，相当于一本书的目录，是为了缩小扫描范围，提高查询效率存在的一种机制。索引是各种数据库进行优化的重要手段。优化的时候优先考虑的因素就是索引。一张表的一个字段可以添加一个索引，当然，多个字段联合起来也可以添加索引。


	t_user
	id(idIndex)	  name(nameIndex)	 email(emailIndex)	address  (emailAddressIndex)
	----------------------------------------------------------------------------------
	1				zhangsan...
	2				lisi
	3				wangwu
	4				zhaoliu
	5				hanmeimei
	6				jack
	select * from t_user where name = 'jack';
	以上的这条SQL语句会去name字段上扫描，因为查询条件是：name='jack'
	
	在mysql数据库当中索引也是需要排序的，并且这个索引的排序和TreeSet数据结构相同。TreeSet（TreeMap）底层是一个自平衡的二叉树！
	在mysql当中索引是一个B-Tree数据结构。遵循左小右大原则存放。采用中序遍历方式遍历取数据。

### 1.2、索引的实现原理？

	t_user
	id(PK)					name						每一行记录在硬盘上都有物理存储编号
	----------------------------------------------------------------------------------
	100						zhangsan					0x1111
	120						lisi						0x2222
	99						wangwu					    0x8888
	88						zhaoliu					    0x9999
	101						jack						0x6666
	55						lucy					    0x5555
	130						tom						    0x7777
	
	在任何数据库当中，主键都会自动添加索引对象，id字段上有索引。另外在mysql当中，一个字段上如果有unique约束的话，也会自动添加索引。
	
	在任何数据库当中，任何一张表的任何一条记录在硬盘存储上都有一个硬盘的物理存储编号。
	
	在mysql当中，索引是一个单独的对象，不同的存储引擎以不同的形式存在。
	    在MyISAM，索引存储在一个.MYI文件中。
	    在InnoDB，索引存储在一个tablespace当中。
	    在MEMORY，索引被存储在内存当中。
	不管索引存储在哪里，索引在mysql当中都是以树的形式存在。（自平衡二叉树：B-Tree）
	
	什么条件下，我们会考虑给字段添加索引呢？
		条件1：数据量庞大
		条件2：该字段经常出现在where的后面，以条件的形式存在，也就是说这个字段总是被扫描。
		条件3：该字段的DML(insert delete update)操作很少。（因为DML之后，索引需要重新排序。）

### 1.3、索引的创建、删除

	创建索引：
		create index emp_ename_index on emp(ename);
		给emp表的ename字段添加索引，起名：emp_ename_index
	删除索引：
		drop index emp_ename_index on emp;
		将emp表上的emp_ename_index索引对象删除
	
	在mysql当中，怎么查看一个SQL语句是否使用了索引进行检索？
	explain select * from emp where ename = 'KING';
	+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
	| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |
	+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
	|  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL |   14 | Using where |
	+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
	rows=14 type=ALL,扫描了14条记录，说明没有使用索引。
	
	create index emp_ename_index on emp(ename);
	explain select * from emp where ename = 'KING';
	+----+-------------+-------+------+-----------------+-----------------+---------+-------+------+-------------+
	| id | select_type | table | type | possible_keys   | key             | key_len | ref   | rows | Extra       |
	+----+-------------+-------+------+-----------------+-----------------+---------+-------+------+-------------+
	|  1 | SIMPLE      | emp   | ref  | emp_ename_index | emp_ename_index | 33      | const |    1 | Using where |
	+----+-------------+-------+------+-----------------+-----------------+---------+-------+------+-------------+
	rows=1 type=ref，只扫描哦了一条记录，使用了索引

### 1.4、索引失效

	失效的第1种情况：
		select * from emp where ename like '%T';
		ename上即使添加了索引，也不会走索引，因为模糊匹配当中以“%”开头了！
		尽量避免模糊查询的时候以“%”开始。
		explain select * from emp where ename like '%T';
		+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
		| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |
		+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
		|  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL |   14 | Using where |
		+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
	
	失效的第2种情况：
		使用or的时候会失效，如果使用or那么要求or两边的条件字段都要有索引，才会走索引，如果其中有一个字段没有索引，那么另一个字段上的索引也不会实现。所以不建议使用or。
		mysql> explain select * from emp where ename = 'KING' or job = 'MANAGER';
		+----+-------------+-------+------+-----------------+------+---------+------+------+-------------+
		| id | select_type | table | type | possible_keys   | key  | key_len | ref  | rows | Extra       |
		+----+-------------+-------+------+-----------------+------+---------+------+------+-------------+
		|  1 | SIMPLE      | emp   | ALL  | emp_ename_index | NULL | NULL    | NULL |   14 | Using where |
		+----+-------------+-------+------+-----------------+------+---------+------+------+-------------+
	
	失效的第3种情况：
		使用复合索引的时候，没有使用左侧的字段查找，索引失效。
		什么是复合索引？两个字段，或者更多的字段联合起来添加一个索引，叫做复合索引。
		create index emp_job_sal_index on emp(job,sal);
		explain select * from emp where job = 'MANAGER';
		+----+-------------+-------+------+-------------------+-------------------+---------+-------+------+-------------+
		| id | select_type | table | type | possible_keys     | key               | key_len | ref   | rows | Extra       |
		+----+-------------+-------+------+-------------------+-------------------+---------+-------+------+-------------+
		|  1 | SIMPLE      | emp   | ref  | emp_job_sal_index | emp_job_sal_index | 30      | const |    3 | Using where |
		+----+-------------+-------+------+-------------------+-------------------+---------+-------+------+-------------+
		按照复合索引index(job,sal)的左侧字段job进行查找，使用了索引。
		explain select * from emp where sal = 800;
		+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
		| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |
		+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
		|  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL |   14 | Using where |
		+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
		按照复合索引index(job,sal)的右侧字段sal进行查找，没有使用索引。
		
	失效的第4种情况：
		在where当中索引列参加了运算，索引失效。
		create index emp_sal_index on emp(sal);
		explain select * from emp where sal = 800;
		+----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+
		| id | select_type | table | type | possible_keys | key           | key_len | ref   | rows | Extra       |
		+----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+
		|  1 | SIMPLE      | emp   | ref  | emp_sal_index | emp_sal_index | 9       | const |    1 | Using where |
		+----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+
		sal没有运算，使用索引
		explain select * from emp where sal+1 = 800;
		+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
		| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |
		+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
		|  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL |   14 | Using where |
		+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
		sal参加了运算，没有使用索引
		
	失效的第5种情况：
		在where当中索引列使用了函数
		explain select * from emp where lower(ename) = 'smith';
		+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
		| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |
		+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
		|  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL |   14 | Using where |
		+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
		
	失效的第6...
	失效的第7...

### 1.5、索引的分类

	单一索引：一个字段上添加索引。
	复合索引：两个字段或者更多的字段上添加索引。
	主键索引：主键上添加索引。
	唯一性索引：具有unique约束的字段上添加索引。
	.....
	注意：唯一性比较弱的字段上添加索引用处不大。

## 2、视图

### 2.1、什么是视图

站在不同的角度去看待同一份数据。

### 2.2、视图对象的创建、删除

	表复制：create table dept2 as select * from dept;
	select * from dept2;
	+--------+------------+----------+
	| DEPTNO | DNAME      | LOC      |
	+--------+------------+----------+
	|     10 | ACCOUNTING | NEW YORK |
	|     20 | RESEARCH   | DALLAS   |
	|     30 | SALES      | CHICAGO  |
	|     40 | OPERATIONS | BOSTON   |
	+--------+------------+----------+
	
	创建视图对象：
		create view dept2_view as select * from dept2;
	删除视图对象：
		drop view dept2_view;
	注意：只有DQL查询语句才能以view的形式创建。create view view_name as DQL语句;

### 2.3、用视图做什么

我们可以面向视图对象进行增删改查，对视图对象的增删改查，会导致原表被操作！

	select * from dept2_view; //面向视图查询
	insert into dept2_view(deptno,dname,loc) values(60,'SALES', 'BEIJING');
	select * from dept2;// 查询原表数据
	+--------+------------+----------+
	| DEPTNO | DNAME      | LOC      |
	+--------+------------+----------+
	|     10 | ACCOUNTING | NEW YORK |
	|     20 | RESEARCH   | DALLAS   |
	|     30 | SALES      | CHICAGO  |
	|     40 | OPERATIONS | BOSTON   |
	|     60 | SALES      | BEIJING  |
	+--------+------------+----------+
	
	delete from dept2_view;
	select * from dept2;
	Empty set (0.00 sec)


	create view 
		emp_dept_view
	as
		select 
			e.ename,e.sal,d.dname
		from
			emp e
		join
			dept d
		on
			e.deptno = d.deptno;
	select * from emp_dept_view;
	+--------+---------+------------+
	| ename  | sal     | dname      |
	+--------+---------+------------+
	| CLARK  | 2450.00 | ACCOUNTING |
	| KING   | 5000.00 | ACCOUNTING |
	| MILLER | 1300.00 | ACCOUNTING |
	| SMITH  |  800.00 | RESEARCH   |
	| JONES  | 2975.00 | RESEARCH   |
	| SCOTT  | 3000.00 | RESEARCH   |
	| ADAMS  | 1100.00 | RESEARCH   |
	| FORD   | 3000.00 | RESEARCH   |
	| ALLEN  | 1600.00 | SALES      |
	| WARD   | 1250.00 | SALES      |
	| MARTIN | 1250.00 | SALES      |
	| BLAKE  | 2850.00 | SALES      |
	| TURNER | 1500.00 | SALES      |
	| JAMES  |  950.00 | SALES      |
	+--------+---------+------------+
	
	//面向视图更新
	update emp_dept_view set sal = 1000 where dname = 'ACCOUNTING';
	select * from emp;
	+-------+--------+-----------+------+------------+---------+---------+--------+
	| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |
	+-------+--------+-----------+------+------------+---------+---------+--------+
	|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |
	|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |
	|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |
	|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |
	|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |
	|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |
	|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 1000.00 |    NULL |     10 |
	|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |
	|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 1000.00 |    NULL |     10 |
	|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |
	|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |
	|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |
	|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |
	|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1000.00 |    NULL |     10 |
	+-------+--------+-----------+------+------------+---------+---------+--------+
	// 原表数据被更新
	
	视图对象在实际开发中到底有什么用：方便，简化开发，利于维护
	视图的使用可以像table一样进行增删改查等操作。
	视图不是在内存当中，视图对象也是存储在硬盘上的，不会消失。

## 3、DBA常用命令

	新建用户
	creat user mayjaneboy identified by '123456';
	用户名 mayjaneboy 密码 123456
	
	数据导出 这个操作是在cmd或者powershell中进行的
	mysqldump mayjaneboy>C:\mayjaneboy.sql -uroot -p159300
	导出指定的表
	mysqldump mayjaneboy emp>C:\mayjaneboy_emp.sql -uroot -p159300
	
	数据导入
	需要先登录到mysql数据库服务器上。
	然后创建数据库：create database mayjaneboy;
	使用数据库：use mayjaneboy;
	然后初始化数据库：source C:\mayjaneboy.sql

## 4、数据库设计范式

### 4.1、什么是数据库设计范式

​	数据库表的设计依据，怎么进行数据库表的设计。数据库设计范式共有3个。	

	第一范式：要求任何一张表必须有主键，每一个字段原子性不可再分。
	第二范式：建立在第一范式的基础之上，要求所有非主键字段完全依赖主键，不要产生部分依赖。
	第三范式：建立在第二范式的基础之上，要求所有非主键字段直接依赖主键，不要产生传递依赖。
	设计数据库表的时候，按照以上的范式进行，可以避免表中数据的冗余，空间的浪费。

### 4.2、第一范式

​	必须有主键，并且每一个字段都是原子性不可再分。

	学生编号    学生姓名        联系方式
	------------------------------------------
	1001		张三		zs@gmail.com,1359999999
	1002		李四		ls@gmail.com,13699999999
	1001		王五		ww@163.net,13488888888
	
	以上学生表不满足第一范式。第一：没有主键。第二：联系方式可以分为邮箱地址和电话
	学生编号(pk)        学生姓名	 邮箱地址		  联系电话
	----------------------------------------------------
	1001				张三		zs@gmail.com	1359999999
	1002				李四		ls@gmail.com	13699999999
	1003				王五		ww@163.net		13488888888

### 4.4、第二范式

​	建立在第一范式的基础之上，要求所有非主键字段必须完全依赖主键，不要产生部分依赖。

	学生编号        学生姓名   教师编号  教师姓名
	----------------------------------------
	1001			张三		001		王老师
	1002			李四		002		赵老师
	1003			王五		001		王老师
	1001			张三		002		赵老师
	1个学生可能有多个老师，1个老师有多个学生。多对多关系！
	学生编号+教师编号(pk)	学生姓名         教师姓名
	----------------------------------------------------
	1001	 001		   张三			王老师
	1002	 002		   李四			赵老师
	1003	 001		   王五			王老师
	1001	 002		   张三			赵老师
	学生编号 教师编号，两个字段联合做主键，复合主键（PK: 学生编号+教师编号）
	经过修改之后，以上的表满足了第一范式。但不满足第二凡是，“张三”依赖1001，“王老师”依赖001，显然产生了部分依赖。数据冗余了。空间浪费了。“张三”重复了，“王老师”重复了。
	
	为了让以上的表满足第二范式，需要这样设计：使用三张表来表示多对多的关系
	学生表
		学生编号(pk)		学生名字
		--------------------------
		1001				张三
		1002				李四
		1003				王五
		教师表
		教师编号(pk)		教师姓名
		-------------------------
		001					王老师
		002					赵老师
		学生教师关系表
		id(pk)			学生编号(fk)	  教师编号(fk)(加外键约束)
		------------------------------------------------------
		1					1001			001
		2					1002			002
		3					1003			001
		4					1001			002

### 4.5、第三范式

第三范式建立在第二范式的基础上，要求所有非主键字段必须直接依赖主键，不要产生传递依赖。

	学生编号（PK）   学生姓名  班级编号   班级名称
	----------------------------------------
		1001		张三		01		一年一班
		1002	    李四		02		一年二班
		1003		王五		03		一年三班
		1004		赵六		03		一年三班
	一个班级对应多位学生，一个学生只对应一个班级。一对多关系
	满足第一范式，有主键。
	满足第二范式，因为主键不是复合主键，没有产生部分依赖。
	不满足第三范式：一年一班依赖01，01依赖1001，产生了传递依赖。
		班级表：一
		班级编号(pk)				班级名称
		----------------------------------------
		01								一年一班
		02								一年二班
		03								一年三班
		学生表：多
		学生编号（PK）       学生姓名     班级编号(fk)(加外键约束)
		-------------------------------------------
		1001				张三			01			
		1002				李四			02			
		1003				王五			03			
		1004				赵六			03		
	
	数据库设计三范式是理论上的，实践和理论有的时候有偏差，最终的目的都是为了满足客户的需求。
	有的时候会拿冗余换执行速度。因为在sql当中，表和表之间连接次数越多，效率越低。并且对于开发人员来说，sql语句的编写难度也会降低。
